<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Overview</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Net</span> <span class="project-version">0.3.3-beta5</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="echo.html"><div class="inner"><span>An echo server</span></div></a></li><li class="depth-1 "><a href="chat.html"><div class="inner"><span>A chat server</span></div></a></li><li class="depth-1 "><a href="tls.html"><div class="inner"><span>TLS support</span></div></a></li><li class="depth-1 "><a href="http-server.html"><div class="inner"><span>HTTP servers</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>net</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>codec</span></div></div></li><li class="depth-3"><a href="net.codec.b64.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>b64</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>core</span></div></div></li><li class="depth-3"><a href="net.core.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-2"><a href="net.http.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>http</span></div></a></li><li class="depth-3 branch"><a href="net.http.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-3"><a href="net.http.server.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>server</span></div></a></li><li class="depth-2 branch"><a href="net.ssl.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>ssl</span></div></a></li><li class="depth-2 branch"><a href="net.tcp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tcp</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ty</span></div></div></li><li class="depth-3 branch"><a href="net.ty.bootstrap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bootstrap</span></div></a></li><li class="depth-3 branch"><a href="net.ty.buffer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buffer</span></div></a></li><li class="depth-3 branch"><a href="net.ty.channel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>channel</span></div></a></li><li class="depth-3 branch"><a href="net.ty.future.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>future</span></div></a></li><li class="depth-3"><a href="net.ty.pipeline.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pipeline</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#overview" name="overview"></a>Overview</h1>
<h2><a href="#the-need-for-asynchronous-network-programming" name="the-need-for-asynchronous-network-programming"></a>The need for asynchronous network programming</h2>
<p>Before diving into the details of net, let’s look at what it brings and why it may be needed. Conventional wisdom - especially on the JVM - mandates that network programming lends itself better to synchronous programming.</p>
<p>Indeed, it is easier to reason as if each discussion with a client happened in isolation:</p>
<pre><code>(defn handle-client [client]
  (future ;; One thread per client
    (loop []
      (let [command (read-command client)] ;; Wait for I/O
        (when-not (= :quit command)
          (handle-command command)
	      (recur))))))
</code></pre>
<p>In the code above, an entire thread is stopped, waiting for I/O for each read-command call. Unless commands come-in constantly, this means that most of the thread’s time will be wasted waiting on I/O.</p>
<p>Handle each client in a separate thread - or processus as was standard on UNIX platforms - reaches system limits quite easily. The JVM incurs a penalty for each created thread and the thread scheduler is not meant to efficiently manage thousand or millions of threads.</p>
<p>Some <a href="http://erlang.org">platforms</a> have been specifically built to permit this programming approach for large number of clients, through the use of low-cost lightweight threads.</p>
<p>Asynchronous programming allows waiting for I/O on several operations at once, and being signalled of I/O events. In C, this is what the <code>select</code> and <code>poll</code> system calls provide. On the JVM, this is the role of the <code>java.nio</code> subsystem, which allows calling <code>select</code> on a <code>selector</code>.</p>
<p>Most programming platforms extend this programming model to provide an <em>event loop</em>: A mechanism to register callbacks associated with I/O events.</p>
<p>The downside of asynchronous programming is that it is up to the programmer to keep track of the current state of a connection, since I/O is decoupled from processing. This can be done through the use of <em>finite state machines</em>, commonly used in asynchronous programming. When working with event loops, this involves registering callbacks for events. Here is a canonical example on top of Javascript:</p>
<pre><code>(def xhr goog.net.XhrIo)

(.send xhr "http://spootnik.org" (fn [response] (handle-body response)))
</code></pre>
<p>As you may imagine, nesting several callbacks quickly leads to confusing code which is hard to maintain.</p>
<p>Fortunately, Clojure provides an elegant way to deal with pending results thanks to the <a href="https://github.com/clojure/core.async">core.async</a> library. The channel abstraction, inspired by <a href="https://golang.org">golang</a> allows writing code that looks synchronous but parks lightweight threads when waiting for results:</p>
<pre><code>(def xhr goog.net.XhrIo)

(defn send-xhr [url]
  (let [p (promise-chan)]
     (.send xhr url (fn [response] (put! p response)))
     p))
	 
(go
  (let [resp (&lt;! (send-xhr "http://spootnik.org"))]
    (handle-body response)))
</code></pre>
<p>On the JVM, <a href="http://netty.io">netty</a> provides a very efficient event loop implementation with mechanisms to build processing pipelines. The idea behind pipelines is to break the handling of incoming and outgoing payloads into several independent finite state machines which each hand over their result to the next handler.</p>
<p>This approach is very similar to the composition of ring wrappers commonly used in clojure. Another way to look at the pipeline idea is the common onion analogy, each step in the pipeline is a layer of an onion, down to the actual <em>business logic</em> handler.</p>
<p>Let’s consider the case of a simple RPC server. The service is exposed over TLS and the protocol follows the standard telnet CRLF line-based frames protocol.</p>
<p>Incoming commands take the form <opcode>:</opcode></p>
<pre><code>"start-engine"
"stop-engine"
"thrust-engine"
</code></pre>
<p>Responses may be either <code>OK</code> or <code>ERR &lt;message&gt;</code>.</p>
<p>To build an appropriate pipeline, we will need:</p>
<ul>
  <li>TLS handling</li>
  <li>line-by-line frame extraction</li>
  <li>coercion to string</li>
  <li>handing-out to the handler</li>
</ul>
<pre><code>+--------------------------+
|                        ^ |
|  | TLS handling        | |
|  v                       |
+--------------------------+
|                          |
|  | line frame decoder    |
|  v                       |
+--------------------------+
|                          |
|  | string decoding       |
|  v                       |
+--------------------------+
|                        ^ |
|    string encoding     | |
|                          |
+--------------------------+
|                        ^ |
|    line frame encoder  | |
|                          |
+--------------------------+
|                          |
| |  read timeout handler  |
| v                        |
+--------------------------+
|                          |
|    our handler           |
|                          |
+--------------------------+
</code></pre>
<p>Netty provides simple facilities to create this layered approach, allowing library consumers to plug-in their logic handling code without worrying about handling low-level payload handling code.</p>
<p>In addition to this simple programming layer, Netty also handles a thread-pool to execute handler callbacks, separating threads dedicated to I/O waiting from threads dedicated to processing.</p>
<p>While avoiding the expensive model of reserving one thread per connection, this allows for scalable handling of a large number of connections.</p>
<p>As a thin wrapper on top of Netty, net provides Clojure facilities to build these handling pipelines in - hopefully - idiomatic clojure. For a more all-encompassing framework on top of Netty, readers are encouraged to also consider <a href="http://aleph.io">aleph</a>. Net aims to provide thin wrapping for people familiar with netty and happy to work mostly with <a href="https://github.com/clojure/core.async">core.async</a> as their asynchronous channel interface.</p>
<p>Now that you hopefully have a better idea of each foundation net builds on top of, you can look at how to build servers and clients with it. Here are a few additional walk-through guides:</p>
<ul>
  <li><a href="echo.html">An echo server</a></li>
  <li><a href="chat.html">A chat server</a></li>
  <li><a href="tls.html">TLS support</a></li>
  <li><a href="http-server.html">HTTP servers</a></li>
</ul></div></div></div></body></html>